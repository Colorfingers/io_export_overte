from ..export_params import ExportParams
from .base_entity import BaseEntity
import os, re, json

class MaterialEntity(BaseEntity):

    generated_data = None

    def __init__(self, obj):
        super().__init__(obj)
        self.generated_data = None

    def santitize_image_name(self, image, output_dir, relpath):
        os.makedirs(output_dir + '/' + ExportParams.textures_path, exist_ok=True)

        file_format = image.file_format
        extension = '.png'

        if file_format == 'BMP':
            extension = '.bmp'
        elif file_format == 'IRIS':
            extension = '.sgi'
        elif file_format == 'PNG':
            extension = '.png'
        elif file_format == 'JPEG':
            extension = '.jpg'
        elif file_format == 'JPEG2000':
            extension = '.jp2'
        elif file_format == 'TARGA' or file_format == 'TARGA_RAW':
            extension = '.tga'
        elif file_format == 'OPEN_EXR':
            extension = '.exr'
        elif file_format == 'TIFF':
            extension = '.tif'
        elif file_format == 'HDR':
            extension = '.hdr'
        elif file_format == 'WEBP':
            extension = '.webp'

        # blender will append ".001" on an object name if it's name clashes with another. We want .png at the end.
        # to combat this, we detect the .001 at the end (any number), then put it inside the name and append .png at the end.
        filename = re.sub('(\.\w+)(\.\d+)?$', '\\2', image.name) + extension
        filepath = output_dir + '/' + ExportParams.textures_path + filename
        file_url = ExportParams.get_url(ExportParams.textures_path + filename)

        if relpath is not None:
            file_url = os.path.relpath(filepath, relpath)

        originalpath = image.filepath_raw
        image.filepath_raw = filepath
        image.save()
        image.filepath_raw = originalpath

        return file_url

    def generate(self, output_dir, relpath = None):
        mat = self.obj

        if mat.overte.material_auto_generate == False:
            return

        # material already generated by an another entity, no need to do it again
        if mat.name in ExportParams.materials_dict:
            return

        #this is default data, as a reference to where I should shove things - @989onan
        matdata = {
            "materialVersion": 1,
            "materials": [
                {
                    "albedo": [
                        1,
                        1,
                        1
                    ],
                    "emissive": [
                        0,
                        0,
                        0
                    ],
                    "scattering": 0,
                    "cullFaceMode": "CULL_BACK"
                }
            ]
        }
        if not mat.use_nodes or not mat.node_tree:
            return
        tree = mat.node_tree
        nodes = tree.nodes

        output = None
        #find an output node with a principled going into it.
        for n in nodes:
            if n.type == 'OUTPUT_MATERIAL':
                if len(n.inputs["Surface"].links) > 0:
                    if n.inputs["Surface"].links[0].from_node:
                        if n.inputs["Surface"].links[0].from_node.type == "BSDF_PRINCIPLED":
                            output = n
                            break

        if not output:
            return

        principled = output.inputs["Surface"].links[0].from_node
        matdata["materials"][0]["albedo"] = list(principled.inputs['Base Color'].default_value[:3])
        matdata["materials"][0]["opacity"] = principled.inputs['Alpha'].default_value
        matdata["materials"][0]["metallic"] = principled.inputs['Metallic'].default_value
        matdata["materials"][0]["roughness"] = principled.inputs['Roughness'].default_value
        matdata["materials"][0]["emissive"] = principled.inputs['Emission'].default_value[:3]
        
        try: 
            base_color_source = principled.inputs["Base Color"].links[0].from_node
            if base_color_source.type == "TEX_IMAGE":
                matdata["materials"][0]["albedoMap"] = self.santitize_image_name(base_color_source.image, output_dir, relpath)
                matdata["materials"][0]["albedo"] = [1, 1, 1]
        except Exception as e:
            print(e)
        
        try: 
            base_color_source = principled.inputs["Alpha"].links[0].from_node
            if base_color_source.type == "TEX_IMAGE":
                matdata["materials"][0]["opacityMap"] = self.santitize_image_name(base_color_source.image, output_dir, relpath)
        except:
            pass
        
        try: 
            base_color_source = principled.inputs["Emission"].links[0].from_node
            if base_color_source.type == "TEX_IMAGE":
                matdata["materials"][0]["emissiveMap"] = self.santitize_image_name(base_color_source.image, output_dir, relpath)
        except:
            pass
        
        try: 
            base_color_source = principled.inputs["Roughness"].links[0].from_node
            if base_color_source.type == "TEX_IMAGE":
                matdata["materials"][0]["roughnessMap"] = self.santitize_image_name(base_color_source.image, output_dir, relpath)
            elif base_color_source.type == "INVERT":
                matdata["materials"][0]["glossMap"] = self.santitize_image_name(base_color_source.links[1].from_node.image, output_dir, relpath)
        except:
            pass
        
        try: 
            metallic_color_source = None
            specular_color_source = None
            try:
                metallic_color_source = principled.inputs["Metallic"].links[0].from_node
            except:
                pass
            try:
                specular_color_source = principled.inputs["Specular"].links[0].from_node
            except:
                pass
            
            if metallic_color_source:
                if metallic_color_source.type == "TEX_IMAGE":
                    matdata["materials"][0]["metallicMap"] = self.santitize_image_name(metallic_color_source.image, output_dir, relpath)
                    specular_color_source = None
            if specular_color_source:
                if specular_color_source.type == "TEX_IMAGE":
                    matdata["materials"][0]["specularMap"] = self.santitize_image_name(specular_color_source.image, output_dir, relpath)
        except:
            pass
        
        try: 
            normal_data_type = principled.inputs["Normal"].links[0].from_node
            if normal_data_type.type == "NORMAL_MAP":
                matdata["materials"][0]["normalMap"] = self.santitize_image_name(normal_data_type.inputs['Color'].links[0].from_node.image, output_dir, relpath)
            elif normal_data_type.type == "BUMP":
                matdata["materials"][0]["bumpMap"] = self.santitize_image_name(normal_data_type.links[2].from_node.image, output_dir, relpath)
        except:
            pass
            
        lightmapped_image_node = None
        for n in nodes:
            if n.type == 'OUTPUT_AOV':
                if n.name == "Lightmap":
                    if len(n.inputs["Color"].links) > 0:
                        if n.inputs["Color"].links[0].from_node:
                            if n.inputs["Color"].links[0].from_node.type == "TEX_IMAGE":
                                lightmapped_image_node = n.inputs["Color"].links[0].from_node
                                break
        if lightmapped_image_node:
            matdata["materials"][0]["lightMap"] = self.santitize_image_name(lightmapped_image_node.image, output_dir, relpath)

            # Fix for lightmaps' albedo.
            # When lightmap is set together with texture image, everything is 2x times darker
            if ExportParams.lightmap_brightness != 0:
                matdata["materials"][0]["albedo"][0] += ExportParams.lightmap_brightness
                matdata["materials"][0]["albedo"][1] += ExportParams.lightmap_brightness
                matdata["materials"][0]["albedo"][2] += ExportParams.lightmap_brightness

        self.generated_data = matdata

    def get_material(self):
        material = {}

        materialUrl = ''
        materialData = self.obj.overte.material_data

        if self.obj.name in ExportParams.materials_dict:
            # this material was already exported, so let's put here an another material's UUID
            materialUrl = ExportParams.materials_dict[self.obj.name]
        elif self.obj.overte.material_url == 'materialData':
            materialUrl = 'materialData'
        elif self.obj.overte.material_url != '':
            materialUrl = ExportParams.get_url(self.obj.overte.material_url)

        if self.generated_data is not None:
            materialUrl = 'materialData'
            materialData = json.dumps(self.generated_data)

        if materialUrl != '':
            material["materialURL"] = materialUrl

        if materialData != '':
            material["materialData"] = materialData

        if self.obj.overte.material_priority != 0:
            material["priority"] = self.obj.overte.material_priority

        if self.obj.overte.material_mapping_mode != 'default':
            material["materialMappingMode"] = self.obj.overte.material_mapping_mode

        if sum(self.obj.overte.material_position) > 0.0:
            material["materialMappingPos"] = {
                "x": self.obj.overte.material_position[0],
                "y": self.obj.overte.material_position[1],
            }

        scale = self.obj.overte.material_scale
        if scale[0] != 1.0 or scale[1] != 1.0:
            material["materialMappingScale"] = {
                "x": scale[0],
                "y": scale[1],
            }

        if self.obj.overte.material_rotation != 0.0:
            material["materialMappingRot"] = self.obj.overte.material_rotation

        if self.obj.overte.material_repeat != True:
            material["materialRepeat"] = self.obj.overte.material_repeat

        return material

    def export(self, parentEntity):
        entity = super().export("Material")
        material = self.get_material()

        if ExportParams.use_material_references and self.obj.name not in ExportParams.materials_dict:
            ExportParams.materials_dict[self.obj.name] = entity['id']

        materialEntity = {
            "name": parentEntity["name"] + '.' + entity["name"],
            "position": { "x": 0, "y": 0, "z": 0 },
            "rotation": { "x": 0, "y": 0, "z": 0, "w": 1 },
            "queryAACube": parentEntity["queryAACube"],
            "parentID": parentEntity["id"]
        }
        return {**entity, **materialEntity, **material}

    def draw_panel(self, layout):
        box = layout.box()

        enabled = self.obj.overte.material_auto_generate == False
        row = box.row()
        row.enabled = enabled
        row.prop(self.obj.overte, "material_url")
        row = box.row()
        row.enabled = enabled
        row.prop(self.obj.overte, "material_data")
        row = box.row()
        row.prop(self.obj.overte, "material_auto_generate")

        row = box.row()
        row.prop(self.obj.overte, "material_priority")
        row = box.row()
        row.prop(self.obj.overte, "material_mapping_mode")
        row = box.row()
        row.prop(self.obj.overte, "material_position")
        row = box.row()
        row.prop(self.obj.overte, "material_scale")
        row = box.row()
        row.prop(self.obj.overte, "material_rotation")
        row = box.row()
        row.prop(self.obj.overte, "material_repeat")

        self.draw_entity_panel(layout)
        self.draw_behavior_panel(layout)
        self.draw_script_panel(layout)
        self.draw_physics_panel(layout)
